/**
 * 本源码配套的课程为 - 从0到1动手写FAT32文件系统。每个例程对应一个课时，尽可能注释。
 * 作者：李述铜
 * 课程网址：http://01ketang.cc
 * 版权声明：本源码非开源，二次开发，或其它商用前请联系作者。
 */
#include "xfat.h"
#include "xdisk.h"

u8_t temp_buffer[512];

/**
 * 初始化磁盘设备
 * @param disk 初始化的设备
 * @param name 设备的名称
 * @return
 */
xfat_err_t xdisk_open(xdisk_t *disk, const char * name, xdisk_driver_t * driver, void * init_data) {
    xfat_err_t err;

    disk->driver = driver;

    // 底层驱动初始化
    err = disk->driver->open(disk, init_data);
    if (err < 0) {
        return err;
    }

    disk->name = name;
    return FS_ERR_OK;
}

/**
 * 关闭存储设备
 * @param disk
 * @return
 */
xfat_err_t xdisk_close(xdisk_t * disk) {
    xfat_err_t err;

    err = disk->driver->close(disk);
    if (err < 0) {
        return err;
    }

    return err;
}

/**
 * 从设备中读取指定扇区数量的数据
 * @param disk 读取的磁盘
 * @param buffer 读取数据存储的缓冲区
 * @param start_sector 读取的起始扇区
 * @param count 读取的扇区数量
 * @return
 */
xfat_err_t xdisk_read_sector(xdisk_t *disk, u8_t *buffer, u32_t start_sector, u32_t count) {
    xfat_err_t err;

    if (start_sector + count >= disk->total_sector) {
        return FS_ERR_PARAM;
    }

    err = disk->driver->read_sector(disk, buffer, start_sector, count);
    return err;
}

/**
 * 向设备中写指定的扇区数量的数据
 * @param disk 写入的存储设备
 * @param buffer 数据源缓冲区
 * @param start_sector 写入的起始扇区
 * @param count 写入的扇区数
 * @return
 */
xfat_err_t xdisk_write_sector(xdisk_t *disk, u8_t *buffer, u32_t start_sector, u32_t count) {
    xfat_err_t err;

    if (start_sector + count >= disk->total_sector) {
        return FS_ERR_PARAM;
    }

    err = disk->driver->write_sector(disk, buffer, start_sector, count);
    return err;
}

/**
 * 获取扩展分区下的子分区数量
 * @param disk 扩展分区所在的存储设备
 * @param start_sector 扩展分区所在的起始扇区
 * @param count 查询得到的子分区数量
 * @return
 */
static xfat_err_t disk_get_extend_part_count(xdisk_t * disk, u32_t start_sector, u32_t * count) {
    int r_count = 0;
    u8_t * disk_buffer = temp_buffer;

    u32_t ext_start_sector = start_sector;
    do {
        mbr_part_t * part;

        // 读取扩展分区的mbr
        int err = xdisk_read_sector(disk, disk_buffer, start_sector, 1);
        if (err < 0) {
            return err;
        }

        // 当前分区无效，立即退出
        part = ((mbr_t *)disk_buffer)->part_info;
        if (part->system_id == FS_NOT_VALID) {
            break;
        }

        r_count++;

        // 没有后续分区, 立即退出
        if ((++part)->system_id != FS_EXTEND) {
            break;
        }

        // 寻找下一分区
        start_sector = ext_start_sector + part->relative_sectors;
    } while (1);

    *count = r_count;
    return FS_ERR_OK;
}

/**
 * 获取设备上总的分区数量
 * @param disk 查询的存储设备
 * @param count 分区数存储的位置
 * @return
 */
xfat_err_t xdisk_get_part_count(xdisk_t *disk, u32_t *count) {
	int r_count = 0, i = 0;
    mbr_part_t * part;
    u8_t * disk_buffer = temp_buffer;
    u8_t extend_part_flag = 0;
    u32_t start_sector[4];

    // 读取mbr区
	int err = xdisk_read_sector(disk, disk_buffer, 0, 1);
	if (err < 0) {
		return err;
	}

	// 解析统计主分区的数量，并标记出哪个分区是扩展分区
	part = ((mbr_t *)disk_buffer)->part_info;
	for (i = 0; i < MBR_PRIMARY_PART_NR; i++, part++) {
		if (part->system_id == FS_NOT_VALID) {
            continue;
        } else if (part->system_id == FS_EXTEND) {
            start_sector[i] = part->relative_sectors;
            extend_part_flag |= 1 << i;
        } else {
            r_count++;
        }
	}

	// 统计各个扩展分区下有多少个子分区
    if (extend_part_flag) {
        for (i = 0; i < MBR_PRIMARY_PART_NR; i++) {
            if (extend_part_flag & (1 << i)) {
                u32_t ext_count = 0;
                err = disk_get_extend_part_count(disk, start_sector[i], &ext_count);
                if (err < 0) {
                    return err;
                }

                r_count += ext_count;
            }
        }
    }

    *count = r_count;
	return FS_ERR_OK;
}
